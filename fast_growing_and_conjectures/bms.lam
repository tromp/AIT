-- small lambda term for computing BMS^4(1) = BMS^3(5)
-- corresponding to Haskell code in BMS.hs
-- original design due to Patcail
-- use of tuple numerals due to 50_ft_lock

let
  id  = \x. x;
  K = \x\y. x;

  -- tuple numerals
  -- Tn x = <...<x>...> with n nested 1-tuples
  T0 = id;
  -- 1-tuple
  T1 = \x\f.f x;
  -- tuple successor
  Tsucc = \t\x. \f.f (t x);
  -- tuple predecessor
  Tpred = \t\x. (t x) id;

  -- Tm x (Tn y) = if n < m then y (Tm-1-n x) else x (Tn-m y)
  -- less than
  Tlt = \tn\tm\t\f. tm (K f) (tn (K t));
  Tzero = \tn\t\f. tn (K t) (K f);

  -- add tuple numerals
  Tadd = \tm\tn\x. tm (tn x);
  -- subtract: tuple numeral minus tuple numeral (smaller or equal)
  Tsub = \tn\tm\x. tm id (tn x);

  expand = \mod\m\m0\i.
    Tlt i m0
      (let add = Tadd (m (Tsucc i)) in add (Tlt (add i) (Tadd m0 mod) T0 m0))
      (m (Tsub (Tsucc i) m0));              -- copy array element i+1 - m0

  matrix0 = \n\k. Tlt k (Tadd n n) n T0;    -- two columns of n n's followed by all 0s

  -- take rows-1 as argument
  BMS = \rows1. let                         -- 326 bits
    bms = \matrix\mod. let m0 = matrix T0 in
          Tzero m0 m0
                   (Tadd m0 (bms (expand mod matrix m0) (Tzero mod rows1 (Tpred mod))))
  in bms (matrix0 (Tsucc rows1)) rows1

in BMS (BMS (BMS (BMS T0)))                 -- 350 bits
